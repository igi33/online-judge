-- phpMyAdmin SQL Dump
-- version 4.8.1
-- https://www.phpmyadmin.net/
--
-- Host: localhost
-- Generation Time: Sep 17, 2019 at 10:36 AM
-- Server version: 8.0.11
-- PHP Version: 7.2.6

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `online_judge`
--

USE `online_judge`;

--
-- Dumping data for table `computerlanguages`
--

INSERT INTO `computerlanguages` (`id`, `name`, `extension`, `compilerpath`, `compilerfilename`, `compilecmd`, `executecmd`) VALUES
(2, 'C++ GCC 8.1.0', 'cpp', 'C:/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/bin', 'g++.exe', '-std=c++17 -O2 {0}.cpp -o {0}.exe', '{0}.exe');

--
-- Dumping data for table `submissions`
--

INSERT INTO `submissions` (`id`, `taskid`, `langid`, `userid`, `timesubmitted`, `sourcecode`, `status`, `executiontime`, `executionmemory`) VALUES
(1, 4, 2, 4, '2019-09-03 21:08:38', '#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint n, i, j;\nshort c[2][5006];\nchar s[5006], rs[5006];\n\ninline int lcs (char *s1, char *s2, int n) {\nint i, j;\nfor (i = 1; i <= n; ++i) {\nfor (j = 1; j <= n; ++j) {\nif (s1[i-1] == s2[j-1]) c[1][j] = c[0][j-1]+1;\nelse c[1][j] = max (c[1][j-1], c[0][j]);\n}\nfor (j = 1; j <= n; ++j) c[0][j] = c[1][j];\n}\nreturn (c[1][n]);\n}\n\nint main () {\nscanf (\"%d\\n\", &n);\nfor (i = 0; i < n; ++i) {\nscanf (\"%c\", &s[i]);\nrs[n-i-1] = s[i];\n}\ns[n] = rs[n] = \'\\0\';\nprintf (\"%d\\n\", n - lcs (s, rs, n));\nreturn 0;\n}', 'AC', 16, 0),
(2, 4, 2, 4, '2019-09-03 22:23:02', '#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint n, i, j;\nshort c[2][5006];\nchar s[5006], rs[5006];\n\ninline int lcs (char *s1, char *s2, int n) {\nint i, j;\nfor (i = 1; i <= n; ++i) {\nfor (j = 1; j <= n; ++j) {\nif (s1[i-1] == s2[j-1]) c[1][j] = c[0][j-1]+1;\nelse c[1][j] = max (c[1][j-1], c[0][j]);\n}\nfor (j = 1; j <= n; ++j) c[0][j] = c[1][j];\n}\nreturn (c[1][n]);\n}\n\nint main () {\nscanf (\"%d\\n\", &n);\nfor (i = 0; i < n; ++i) {\nscanf (\"%c\", &s[i]);\nrs[n-i-1] = s[i];\n}\ns[n] = rs[n] = \'\\0\';\nprintf (\"%d\\n\", n - lcs (s, rs, n));\nreturn 0;\n}', 'AC', 15, 0),
(3, 4, 2, 4, '2019-09-03 22:34:18', '#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint n, i, j;\nshort c[2][5006];\nchar s[5006], rs[5006];\n\ninline int lcs (char *s1, char *s2, int n) {\nint i, j;\nfor (i = 1; i <= n; ++i) {\nfor (j = 1; j <= n; ++j) {\nif (s1[i-1] == s2[j-1]) c[1][j] = c[0][j-1]+1;\nelse c[1][j] = max (c[1][j-1], c[0][j]);\n}\nfor (j = 1; j <= n; ++j) c[0][j] = c[1][j];\n}\nreturn (c[1][n]);\n}\n\nint main () {\nscanf (\"%d\\n\", &n);\nfor (i = 0; i < n; ++i)) {\nscanf (\"%c\", &s[i]);\nrs[n-i-1] = s[i];\n}\ns[n] = rs[n] = \'\\0\';\nprintf (\"%d\\n\", n - lcs (s, rs, n));\nreturn 0;\n}', 'CE', 0, 0),
(5, 4, 2, 5, '2019-09-03 23:15:25', '#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint n, i, j;\nshort c[2][5006];\nchar s[5006], rs[5006];\n\ninline int lcs (char *s1, char *s2, int n) {\nint i, j;\nfor (i = 1; i <= n; ++i) {\nfor (j = 1; j <= n; ++j) {\nif (s1[i-1] == s2[j-1]) c[1][j] = c[0][j-1]+1;\nelse c[1][j] = max (c[1][j-1], c[0][j]);\n}\nfor (j = 1; j <= n; ++j) c[0][j] = c[1][j];\n}\nreturn (c[1][n]);\n}\n\nint main () {\nscanf (\"%d\\n\", &n);\nfor (i = 0; i < n; ++i) {\nscanf (\"%c\", &s[i]);\nrs[n-i-1] = s[i];\n}\ns[n] = rs[n] = \'\\0\';\nprintf (\"%d\\n\", n - lcs (s, rs, n));\nreturn 0;\n}', 'RJ', 14, 0),
(7, 5, 2, 5, '2019-09-04 20:58:17', '#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint n, i, j;\nshort c[2][5006];\nchar s[5006], rs[5006];\n\ninline int lcs (char *s1, char *s2, int n) {\nint i, j;\nfor (i = 1; i <= n; ++i) {\nfor (j = 1; j <= n; ++j) {\nif (s1[i-1] == s2[j-1]) c[1][j] = c[0][j-1]+1;\nelse c[1][j] = max (c[1][j-1], c[0][j]);\n}\nfor (j = 1; j <= n; ++j) c[0][j] = c[1][j];\n}\nreturn (c[1][n]);\n}\n\nint main () {\nscanf (\"%d\\n\", &n);\nfor (i = 0; i < n; ++i) {\nscanf (\"%c\", &s[i]);\nrs[n-i-1] = s[i];\n}\ns[n] = rs[n] = \'\\0\';\nprintf (\"%d\\n\", n - lcs (s, rs, n));\nreturn 0;\n}', 'RJ', 70, 0),
(8, 5, 2, 4, '2019-09-15 06:32:44', '#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nstruct edge {\r\n    int start, end, height;\r\n} e[200006];\r\n\r\nlong long depths[100006], maxDepth;\r\nint n, eNum, i, lastNode, s[100006], parents[100006];\r\nbool happyFlag[100006];\r\n\r\ninline bool edge_compare (edge a, edge b) {\r\n    return a.start < b.start;\r\n}\r\n\r\ninline void path (int node) {\r\n    if (parents[node] != 0) path (parents[node]);\r\n    printf (\"\\n%d\", node);\r\n}\r\n\r\ninline void dfs (int v) {\r\n    for (int t = s[v]; t < s[v+1]; ++t)\r\n        if (!happyFlag[e[t].end]) {\r\n            happyFlag[e[t].end] = 1;\r\n            parents[e[t].end] = v;\r\n            depths[e[t].end] = depths[v] + e[t].height;\r\n            dfs (e[t].end);\r\n        }\r\n}\r\n\r\nint main () {\r\n    scanf (\"%d\", &n);\r\n    for (i = 1; i < n; ++i) {\r\n        scanf (\"%d%d%d\", &e[i].start, &e[i].end, &e[i].height);\r\n        e[i+n-1].start = e[i].end;\r\n        e[i+n-1].end = e[i].start;\r\n        e[i+n-1].height = e[i].height;\r\n    }\r\n    eNum = n * 2 - 2;\r\n    sort (e+1, e+eNum+1, edge_compare);\r\n    for (i = eNum; i > 0; --i) s[e[i].start] = i;\r\n    s[n+1] = eNum + 1;\r\n    happyFlag[1] = 1;\r\n    dfs (1);\r\n    maxDepth = 0;\r\n    lastNode = 1;\r\n    for (i = 2; i <= n; ++i)\r\n        if (depths[i] > maxDepth) {\r\n            maxDepth = depths[i];\r\n            lastNode = i;\r\n        }\r\n    printf (\"%lld\", maxDepth);\r\n    path (lastNode);\r\n    return 0;\r\n}\r\n', 'AC', 62, 0),
(9, 5, 2, 4, '2019-09-15 06:33:34', '#include <cstdio>\r\n#include <vector>\r\n#include <queue>\r\n#include <stack>\r\nusing namespace std;\r\n\r\nstruct neighbor {\r\n	int val;\r\n	int node;\r\n};\r\n\r\nint n, i, u, val, v, parent[100001], dpt[100001], maxDpt, maxDptNode;\r\nbool visit[100001];\r\nneighbor x;\r\nqueue<int> q;\r\n//stack<int> q;\r\nvector<neighbor> e[100001];\r\n\r\nvoid echoPath(int node) {\r\n	if (parent[node] != 0) {\r\n		echoPath(parent[node]);\r\n	}\r\n	printf(\"%d\\n\", node);\r\n}\r\n\r\nint main() {\r\n	scanf(\"%d\", &n);\r\n	for (i = 1; i < n; ++i) {\r\n		scanf(\"%d%d%d\", &u, &v, &val);\r\n		x.val = val;\r\n		x.node = v;\r\n		e[u].push_back(x);\r\n		x.node = u;\r\n		e[v].push_back(x);\r\n	}\r\n	maxDpt = 0;\r\n	maxDptNode = 1;\r\n	q.push(1);\r\n	while (!q.empty()) {\r\n		v = q.front();\r\n		//v = q.top();\r\n		q.pop();\r\n		visit[v] = true;\r\n		for (i = 0; i < e[v].size(); ++i) {\r\n			if (!visit[e[v][i].node]) {\r\n				q.push(e[v][i].node);\r\n				parent[e[v][i].node] = v;\r\n				dpt[e[v][i].node] = dpt[v] + e[v][i].val;\r\n				if (dpt[e[v][i].node] > maxDpt) {\r\n					maxDpt = dpt[e[v][i].node];\r\n					maxDptNode = e[v][i].node;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	printf(\"%d\\n\", maxDpt);\r\n	echoPath(maxDptNode);\r\n	return 0;\r\n}\r\n', 'AC', 14, 0),
(15, 14, 2, 4, '2019-09-15 08:57:26', '#include <cstdio>\r\n#include <algorithm>\r\n#include <cstring>\r\nusing namespace std;\r\n \r\nint n, i, c[500000], l, t, key;\r\nchar s[10006], ss[7];\r\n \r\nint main () {\r\n	scanf (\"%s%d\", s, &n);\r\n	l = strlen (s);\r\n	t = l - 4;\r\n	for (i = 0; i <= t; ++i) {\r\n		key = (s[i]-\'a\')*17576+(s[i+1]-\'a\')*676+(s[i+2]-\'a\')*26+(s[i+3]-\'a\');\r\n		if (c[key] == 0) c[key] = i+1;\r\n	}\r\n	for (i = 0; i < n; ++i) {\r\n		scanf (\"%s\", ss);\r\n		key = (ss[0]-\'a\')*17576+(ss[1]-\'a\')*676+(ss[2]-\'a\')*26+(ss[3]-\'a\');\r\n		printf (\"%d\\n\", c[key]);\r\n	}\r\n	return 0;\r\n}\r\n', 'RJ', 10, 0),
(16, 5, 2, 4, '2019-09-15 09:48:02', '    #include <cstdio>\r\n    #include <iostream>\r\n    #include <algorithm>\r\n    using namespace std;\r\n     \r\n    struct edge {\r\n        int start, end, height;\r\n    } e[200006];\r\n     \r\n    long long depths[100006], maxDepth;\r\n    int n, eNum, i, lastNode, s[100006], parents[100006];\r\n    bool happyFlag[100006];\r\n     \r\n    inline bool edge_compare (edge a, edge b) {\r\n        return a.start < b.start;\r\n    }\r\n     \r\n    inline void path (int node) {\r\n        if (parents[node] != 0) path (parents[node]);\r\n        printf (\"\\n%d\", node);\r\n    }\r\n     \r\n    inline void dfs (int v) {\r\n        for (int t = s[v]; t < s[v+1]; ++t)\r\n            if (!happyFlag[e[t].end]) {\r\n                happyFlag[e[t].end] = 1;\r\n                parents[e[t].end] = v;\r\n                depths[e[t].end] = depths[v] + e[t].height;\r\n                dfs (e[t].end);\r\n            }\r\n    }\r\n     \r\n    int main () {\r\n        scanf (\"%d\", &n);\r\n        for (i = 1; i < n; ++i) {\r\n            scanf (\"%d%d%d\", &e[i].start, &e[i].end, &e[i].height);\r\n            e[i+n-1].start = e[i].end;\r\n            e[i+n-1].end = e[i].start;\r\n            e[i+n-1].height = e[i].height;\r\n        }\r\n        eNum = n * 2 - 2;\r\n        sort (e+1, e+eNum+1, edge_compare);\r\n        for (i = eNum; i > 0; --i) s[e[i].start] = i;\r\n        s[n+1] = eNum + 1;\r\n        happyFlag[1] = 1;\r\n        dfs (1);\r\n        maxDepth = 0;\r\n        lastNode = 1;\r\n        for (i = 2; i <= n; ++i)\r\n            if (depths[i] > maxDepth) {\r\n                maxDepth = depths[i];\r\n                lastNode = i;\r\n            }\r\n        printf (\"%lld\", maxDepth);\r\n        path (lastNode);\r\n        return 0;\r\n    }', 'AC', 17, 0),
(17, 5, 2, 4, '2019-09-15 09:52:46', '#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nstruct edge {\r\n    int start, end, height;\r\n} e[200006];\r\n\r\nlong long depths[100006], maxDepth;\r\nint n, eNum, i, lastNode, s[100006], parents[100006];\r\nbool happyFlag[100006];\r\n\r\ninline bool edge_compare (edge a, edge b) {\r\n    return a.start < b.start;\r\n}\r\n\r\ninline void path (int node) {\r\n    if (parents[node] != 0) path (parents[node]);\r\n    printf (\"\\n%d\", node);\r\n}\r\n\r\ninline void dfs (int v) {\r\n    for (int t = s[v]; t < s[v+1]; ++t)\r\n        if (!happyFlag[e[t].end]) {\r\n            happyFlag[e[t].end] = 1;\r\n            parents[e[t].end] = v;\r\n            depths[e[t].end] = depths[v] + e[t].height;\r\n            dfs (e[t].end);\r\n        }\r\n}\r\n\r\nint main () {\r\n    scanf (\"%d\", &n);\r\n    for (i = 1; i < n; ++i) {\r\n        scanf (\"%d%d%d\", &e[i].start, &e[i].end, &e[i].height);\r\n        e[i+n-1].start = e[i].end;\r\n        e[i+n-1].end = e[i].start;\r\n        e[i+n-1].height = e[i].height;\r\n    }\r\n    eNum = n * 2 - 2;\r\n    sort (e+1, e+eNum+1, edge_compare);\r\n    for (i = eNum; i > 0; --i) s[e[i].start] = i;\r\n    s[n+1] = eNum + 1;\r\n    happyFlag[1] = 1;\r\n    dfs (1);\r\n    maxDepth = 0;\r\n    lastNode = 1;\r\n    for (i = 2; i <= n; ++i)\r\n        if (depths[i] > maxDepth) {\r\n            maxDepth = depths[i];\r\n            lastNode = i;\r\n        }\r\n    printf (\"%lld\", maxDepth);\r\n    path (lastNode);\r\n    return 0;\r\n}', 'AC', 13, 0),
(18, 14, 2, 4, '2019-09-15 10:04:40', 'asdasd', 'CE', 0, 0),
(19, 5, 2, 4, '2019-09-15 10:10:13', '#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nstruct edge {\r\n    int start, end, height;\r\n} e[200006];\r\n\r\nlong long depths[100006], maxDepth;\r\nint n, eNum, i, lastNode, s[100006], parents[100006];\r\nbool happyFlag[100006];\r\n\r\ninline bool edge_compare (edge a, edge b) {\r\n    return a.start < b.start;\r\n}\r\n\r\ninline void path (int node) {\r\n    if (parents[node] != 0) path (parents[node]);\r\n    printf (\"\\n%d\", node);\r\n}\r\n\r\ninline void dfs (int v) {\r\n    for (int t = s[v]; t < s[v+1]; ++t)\r\n        if (!happyFlag[e[t].end]) {\r\n            happyFlag[e[t].end] = 1;\r\n            parents[e[t].end] = v;\r\n            depths[e[t].end] = depths[v] + e[t].height;\r\n            dfs (e[t].end);\r\n        }\r\n}\r\n\r\nint main () {\r\n    scanf (\"%d\", &n);\r\n    for (i = 1; i < n; ++i) {\r\n        scanf (\"%d%d%d\", &e[i].start, &e[i].end, &e[i].height);\r\n        e[i+n-1].start = e[i].end;\r\n        e[i+n-1].end = e[i].start;\r\n        e[i+n-1].height = e[i].height;\r\n    }\r\n    eNum = n * 2 - 2;\r\n    sort (e+1, e+eNum+1, edge_compare);\r\n    for (i = eNum; i > 0; --i) s[e[i].start] = i;\r\n    s[n+1] = eNum + 1;\r\n    happyFlag[1] = 1;\r\n    dfs (1);\r\n    maxDepth = 0;\r\n    lastNode = 1;\r\n    for (i = 2; i <= n; ++i)\r\n        if (depths[i] > maxDepth) {\r\n            maxDepth = depths[i];\r\n            lastNode = i;\r\n        }\r\n    printf (\"%lld\", maxDepth);\r\n    path (lastNode);\r\n    return 0;\r\n}', 'AC', 14, 0),
(20, 14, 2, 4, '2019-09-15 10:13:58', '#include <cstdio>\r\n#include <algorithm>\r\n#include <cstring>\r\nusing namespace std;\r\n \r\nint n, i, c[500000], l, t, key;\r\nchar s[10006], ss[7];\r\n \r\nint main () {\r\n	scanf (\"%s%d\", s, &n);\r\n	l = strlen (s);\r\n	t = l - 4;\r\n	for (i = 0; i <= t; ++i) {\r\n		key = (s[i]-\'a\')*17576+(s[i+1]-\'a\')*676+(s[i+2]-\'a\')*26+(s[i+3]-\'a\');\r\n		if (c[key] == 0) c[key] = i+1;\r\n	}\r\n	for (i = 0; i < n; ++i) {\r\n		scanf (\"%s\", ss);\r\n		key = (ss[0]-\'a\')*17576+(ss[1]-\'a\')*676+(ss[2]-\'a\')*26+(ss[3]-\'a\');\r\n		printf (\"%d\\n\", c[key]);\r\n	}\r\n	return 0;\r\n}', 'RJ', 12, 0),
(21, 14, 2, 5, '2019-09-15 10:16:08', '#include <cstdio>\r\n#include <algorithm>\r\n#include <cstring>\r\nusing namespace std;\r\n \r\nint n, i, c[500000], l, t, key;\r\nchar s[10006], ss[7];\r\n \r\nint main () {\r\n	scanf (\"%s%d\", s, &n);\r\n	l = strlen (s);\r\n	t = l - 4;\r\n	for (i = 0; i <= t; ++i) {\r\n		key = (s[i]-\'a\')*17576+(s[i+1]-\'a\')*676+(s[i+2]-\'a\')*26+(s[i+3]-\'a\');\r\n		if (c[key] == 0) c[key] = i+1;\r\n	}\r\n	for (i = 0; i < n; ++i) {\r\n		scanf (\"%s\", ss);\r\n		key = (ss[0]-\'a\')*17576+(ss[1]-\'a\')*676+(ss[2]-\'a\')*26+(ss[3]-\'a\');\r\n		printf (\"%d\\n\", c[key]);\r\n	}\r\n	return 0;\r\n}', 'RJ', 8, 0),
(22, 14, 2, 4, '2019-09-15 10:22:27', '#include <cstdio>\r\n#include <algorithm>\r\n#include <cstring>\r\nusing namespace std;\r\n \r\nint n, i, c[500000], l, t, key;\r\nchar s[10006], ss[7];\r\n \r\nint main () {\r\n	scanf (\"%s%d\", s, &n);\r\n	l = strlen (s);\r\n	t = l - 4;\r\n	for (i = 0; i <= t; ++i) {\r\n		key = (s[i]-\'a\')*17576+(s[i+1]-\'a\')*676+(s[i+2]-\'a\')*26+(s[i+3]-\'a\');\r\n		if (c[key] == 0) c[key] = i+1;\r\n	}\r\n	for (i = 0; i < n; ++i) {\r\n		scanf (\"%s\", ss);\r\n		key = (ss[0]-\'a\')*17576+(ss[1]-\'a\')*676+(ss[2]-\'a\')*26+(ss[3]-\'a\');\r\n		printf (\"%d\\n\", c[key]);\r\n	}\r\n	return 0;\r\n}', 'AC', 8, 0),
(23, 15, 2, 5, '2019-09-16 15:38:00', '#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nint n, i, j, k, l, c, lengths[1006], minLen, minIndex, solLen;\r\nchar s[1006][106], sol[106];\r\n\r\ninline void lengthSearch (int left, int right) {\r\n    int nextLen, till, len = right;\r\n    bool found;\r\n    while (right >= left) {\r\n        len = right == left ? left : (left + right) / 2 + 1;\r\n        found = false;\r\n        till = lengths[minIndex] - len;\r\n        for (i = 0; i <= till; ++i) {\r\n            bool stillMatches = true;\r\n            for (j = 0; j < n; ++j) {\r\n                if (j == minIndex) continue;\r\n                bool matches = false;\r\n                int till2 = lengths[j] - len;\r\n                for (k = 0; k <= till2; ++k) {\r\n                    bool charsMatch = true;\r\n                    for (l = 0; l < len; ++l)\r\n                        if (s[minIndex][i+l] != s[j][k+l]) {\r\n                            charsMatch = false;\r\n                            break;\r\n                        }\r\n                    if (charsMatch) {\r\n                        matches = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!matches) {\r\n                    stillMatches = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (stillMatches) {\r\n                solLen = len;\r\n                for (j = 0; j < len; ++j)\r\n                    sol[j] = s[minIndex][i+j];\r\n                sol[len] = \'\\0\';\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (left == right) return;\r\n        if (found) left = len;\r\n        else right = len - 1;\r\n    }\r\n}\r\n\r\nint main () {\r\n    scanf (\"%d\\n\", &n);\r\n    for (i = 0; i < n; ++i) {\r\n        c = 0;\r\n        do {\r\n            scanf (\"%c\", &s[i][c]);\r\n        } while (s[i][c++] != \'\\n\');\r\n        if (i < n - 1) scanf (\"\\n\");\r\n        s[i][c-1] = \'\\0\';\r\n        lengths[i] = c-1;\r\n    }\r\n    minLen = lengths[0];\r\n    minIndex = 0;\r\n    lengthSearch (1, minLen);\r\n    printf (\"%s\\n\", sol);\r\n    return 0;\r\n}', 'AC', 68, 0),
(24, 15, 2, 4, '2019-09-16 15:43:15', '#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nint n, i, j, k, l, c, lengths[1006], minLen, minIndex, solLen;\r\nchar s[1006][106], sol[106];\r\n\r\ninline void lengthSearch (int left, int right) {\r\n    int nextLen, till, len = right;\r\n    bool found;\r\n    while (right >= left) {\r\n        len = right == left ? left : (left + right) / 2 + 1;\r\n        found = false;\r\n        till = lengths[minIndex] - len;\r\n        for (i = 0; i <= till; ++i) {\r\n            bool stillMatches = true;\r\n            for (j = 0; j < n; ++j) {\r\n                if (j == minIndex) continue;\r\n                bool matches = false;\r\n                int till2 = lengths[j] - len;\r\n                for (k = 0; k <= till2; ++k) {\r\n                    bool charsMatch = true;\r\n                    for (l = 0; l < len; ++l)\r\n                        if (s[minIndex][i+l] != s[j][k+l]) {\r\n                            charsMatch = false;\r\n                            break;\r\n                        }\r\n                    if (charsMatch) {\r\n                        matches = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!matches) {\r\n                    stillMatches = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (stillMatches) {\r\n                solLen = len;\r\n                for (j = 0; j < len; ++j)\r\n                    sol[j] = s[minIndex][i+j];\r\n                sol[len] = \'\\0\';\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (left == right) return;\r\n        if (found) left = len;\r\n        else right = len - 1;\r\n    }\r\n}\r\n\r\nint main () {\r\n    scanf (\"%d\\n\", &n);\r\n    for (i = 0; i < n; ++i) {\r\n        c = 0;\r\n        do {\r\n            scanf (\"%c\", &s[i][c]);\r\n        } while (s[i][c++] != \'\\n\');\r\n        if (i < n - 1) scanf (\"\\n\");\r\n        s[i][c-1] = \'\\0\';\r\n        lengths[i] = c-1;\r\n    }\r\n    minLen = lengths[0];\r\n    minIndex = 0;\r\n    lengthSearch (1, minLen);\r\n    printf (\"%s\\n\", sol);\r\n    return 0;\r\n}', 'AC', 14, 0);

--
-- Dumping data for table `tags`
--

INSERT INTO `tags` (`id`, `name`, `description`) VALUES
(16, 'DFS', ''),
(17, 'BFS', ''),
(20, 'Binary Search', ''),
(22, 'Dynamic Programming', ''),
(26, 'Hashing', '');

--
-- Dumping data for table `tasks`
--

INSERT INTO `tasks` (`id`, `name`, `description`, `memorylimit`, `timelimit`, `userid`, `timesubmitted`, `origin`) VALUES
(4, 'Palin', 'A palindrome is a symmetrical string, that is, a string read identically from left to right as well as from right to left. You are to write a program which, given a string, determines the minimal number of characters to be inserted into the string in order to obtain a palindrome. As an example, by inserting 2 characters, the string \"Ab3bd\" can be transformed into a palindrome (\"dAb3bAd\" or \"Adb3bdA\"). However, inserting fewer than 2 characters does not produce a palindrome. Input: The first line of standard input contains one integer: the length of the input string N, 3≤N≤5000. The second line contains one string with length N. The string is formed from uppercase letters from ‘A’ to ‘Z’, lowercase letters from ‘a’ to ‘z’ and digits from ‘0’ to ‘9’. Uppercase and lowercase letters are to be considered distinct. Output: The first line of standard output contains one integer, which is the desired minimal number.', 67108864, 250, 4, '2019-09-01 18:06:45', 'http://www.z-trening.com/tasks.php?show_task=5000000253'),
(5, 'O-Speleologists', 'Our speleologists Toma and Miloš found out from certain sources that around Three Hills near Sombor town, exists entrance to cave which goes almost to the center of the Earth. But their only goal is to be written in Guinness Book of Records with biggest depth in cave exploring. Cave is system of N halls and N-1 tunnels. First hall is numbered with 1, it is immediately after entering and it is on depth 0. From every hall it is possible to go to many other halls of bigger depth. There is only one way to each hall. Input: In the first row of standard input is integer N. In each of the next N-1 rows there are three integers D1, D2 and VR. D1 and D2 are hall numbers (D1 <> D2) and VR is depth difference between D1 and D2. All numbers on input will be: (1 <= N, D1, D2, VR <= 100,000). Output: In the first output row You need to write what is the maximal depth of Cave. In the next K rows You need to write numbers of halls from first to last on this deepest way. Input data will be so that solution is unique!', 0, 1000, 4, '2019-09-02 18:17:43', 'http://www.z-trening.com/tasks.php?show_task=5000000309'),
(14, 'Magic four', 'Little-Z has a long string of characters, containing only lowercase english letters. In addition, he has a lot of smaller 4 character strings. Write him a program, which will for each 4 character string check it\'s first occurence in main (long) string. Input: In first line, there will be the main string, 5 <= len(STR) <= 10 000. In second line, there will be a number 5 <= N <= 500 000, followed by N lines, each containing a 4 character word. Output: Output N lines, each containing number, representing the position of substring in main string (first place is numbered 1). If such position doesn\'t exist output 0.', 0, 600, 5, '2019-09-05 04:23:56', 'http://www.z-trening.com/tasks.php?show_task=5000000371'),
(15, 'BubbleLock', 'In a dark basement, there is a wooden case with printed solutions to all tasks in this contest. However, the basement has thick walls and a door, and a lock on the door. On the lock, there are n horizontal iron bars, and on each of the bars there is a word with letters of equal width. Each bar can be moved independently to the left or right for one or more widths of a letter. There is at least one letter that is common to all words. Therefore, bars can be lined up so that there is a vertical line of n identical letters above each other (each letter on one bar). To unlock the door, bars should be positioned in such a way that there is a maximal number of such consecutive vertical lines.\r\n\r\nYou are naturally interested in writing a program that solves this problem.\r\n\r\nInput:\r\nFirst line contains a number n, the number of bars, with n = 1000. In each of next n lines, there is a word corresponding to one of the bars. Each word contains only capital letters, and is at least 1 and at most 100 characters long.\r\n\r\n\r\nOutput:\r\nA string of maximal length, that appears in every word as a sequence of consecutive letters. If there is more than one solution, you should print the leftmost one.', 0, 4000, 5, '2019-09-16 15:19:56', 'http://www.z-trening.com/tasks.php?show_task=5000000320'),
(16, 'bogatas', 'Shumadija (a Serbian province) was once full of forests, but it can\'t be proud of them anymore. A huge effort is being made to prevent trees from being unnecessarily cut down. A local newcomer, who is also a very rich man, bought a relatively large piece of land (square-shaped), and he wants to build a house on it. He also wants to make the house as large as possible and and square-shaped with its sides parallel to the sides of the land that the house will be built on.\r\n\r\nThe land is divided into little 1x1 squares. One tree occupies exactly one square. Since the land is big, it\'s very hard to find the largest square with its sides parallel to the sides of the land and with no trees on it. For a given map of the land that describes the position of all the trees, you must find the square with the largest sides and with no trees on it. The length of the square\'s side is the number of 1x1 squares along its side.\r\n\r\nInput:\r\nThe input is read from the standard input. The first line of input contains a number N ( N <= 200) that tells the length of the land\'s sides. In the next line there will be a number P , which is the number of trees positioned on this land. The next P lines contain two numbers that represent the coordinates of a tree.\r\n\r\n\r\nOutput:\r\nOne and only line of the standard output should have only one number, which tells the length of the side of the largest square with no trees in it.', 0, 1000, 5, '2019-09-17 09:00:11', 'http://www.z-trening.com/tasks.php?show_task=5000000006');

--
-- Dumping data for table `tasktags`
--

INSERT INTO `tasktags` (`taskid`, `tagid`) VALUES
(5, 16),
(5, 17),
(15, 20),
(16, 22),
(14, 26);

--
-- Dumping data for table `testcases`
--

INSERT INTO `testcases` (`id`, `taskid`, `input`, `output`) VALUES
(1, 5, '15\r\n1 2 5\r\n6 2 7\r\n11 2 6\r\n2 7 11\r\n1 3 11\r\n12 3 4\r\n1 4 2\r\n4 8 12\r\n5 1 4\r\n5 10 4\r\n5 9 1\r\n14 10 4\r\n13 9 8\r\n13 15 2\n', '16\r\n1\r\n2\r\n7\n'),
(5, 4, '5\r\nAb3bd', '2'),
(6, 4, '10\r\nkatastrofa\r\n', '5\r\n'),
(13, 14, 'abracadabra\n5\nabra\ncada\nacab\nraca\ntaca\n', '1\n5\n0\n3\n0\n'),
(14, 15, '3\r\nTHATBALLOONRISEDTOTHETOP\r\nFOOTBALLWIZARDWASSLEEPY\r\nSOHELOSTBALANCEANDDROPPEDBALLON\n', 'TBAL\n'),
(15, 15, '4\r\nTHISISATESTCASE\r\nTHATHISNOTATC\r\nQWERTYTHISASD\r\nTESTHISNGCASE\n', 'THIS\n'),
(16, 15, '3\r\nasdabcghia\r\naddhuiasdghiasd\r\ntyuiasdghi\n', 'asd\n'),
(17, 16, '5\r\n3\r\n2 2\r\n4 2\r\n4 4\n', '3\n');

--
-- Dumping data for table `users`
--

INSERT INTO `users` (`id`, `username`, `email`, `timeregistered`, `passwordhash`, `passwordsalt`) VALUES
(4, 'igi33', 'stosicigi96@gmail.com', '0000-00-00 00:00:00', 'kqSQI6OQwbWeN34apbpE4dugVAry+y0apxZ31Qfggnq33ZjjTjv85pAYngAXbzkaFDUT/l4oZetT9yYe41Olaw==', '7ssUQNL77hQ9terelhZFKUdRaH5WQxFbthvORjh1EQ2hEGiDMgqz8TWV5A0yZvjI1t7JicchleAApzVOhQmZay7ANH321TQHxtYukx+zwUjJLcmypoK0XmiPMQH/HFbwfotEOLffWNBZvM+M1BBv4MWfxzzL2Hd7qQXKvia3T7k='),
(5, 'igi96', 'stosicigor96@gmail.com', '2019-09-01 15:40:50', 'fdEGBHk9L4G77GIEapJWUv7mrn0KW8eDrpNCWlBxN+GJQl4BetndISN0+29NEdj+r7kNlOwlBEqR8bRtha/S8A==', '8WMr7c6sBonUCwS5tsAtSCtveWwQ1kdOKdO9StjNiE2T5mos+XkOV2ocHzyKFClONo3U1XNfwbb6AP8x9ZkSnst3Xa9xtm0f8Z1KCAer7/2NCnw/pYXqOKyUGcvEmrS7ZpwnxBxcWLiwFwoflyIFR1sTswgKVeRvyFh8xb+TaZ8='),
(6, 'miki', 'miki96@gmail.com', '2019-09-01 19:29:50', 'CbBp79DCdtA0I5js3s5fhwmzSDABA9sAkyvx9Hu31vqWjbJPBcKIA4K925+PFOT/LTuQEE8FhtglFM48jwfscg==', 'z/cr2BeLwOxq/UqBe332BBRnBVS/HtHqBGCm19ujnD04eKsxGnZXbsD+djMZbakpD0CMmr3MfFUK6iNmZhvLwocf7zHFkFn8dFNh+lPnGQseFL2gMsVn08jENgUDhGJF4jEf85r4MZKjtug7BL6aJT/alTIO0+V4Q9p1cPQUp2c='),
(7, 'test', 'test@test.test', '2019-09-06 16:13:51', 'ImN4tFfxcrfu5kQ0qTN0CJ6G/hN2iMgbtJfxHbEHqrwf1BDZaZJDoWkFGSMccNvc+FOVy86S1+HH+jzGJDEjkQ==', 'HnU4g/pz3yVwWXMALCoVqlMxcD81d+MuRHUZDiwiV0tV6TxSySdi8YXqLjXqCSH+JZyCg1vCfMPFmRpJ978eMoRrWzQZpd7mfGlYk1+FKOPlIOWoEotqU7EDNgyCy2UYztubiC9M7QCGAYp2Bt3uE7RQdw+qu0Ohq/tYmMA23ww=');
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
